import numpy as np
import copy
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import random
import sys
import bandits_manchots as bm

## Constante
OFFSET = 0.2


class State:
    """ Etat generique d'un jeu de plateau. Le plateau est represente par une matrice de taille NX,NY,
    le joueur courant par 1 ou -1. Une case a 0 correspond a une case libre.
    * next(self,coup) : fait jouer le joueur courant le coup.
    * get_actions(self) : renvoie les coups possibles
    * win(self) : rend 1 si le joueur 1 a gagne, -1 si le joueur 2 a gagne, 0 sinon
    * stop(self) : rend vrai si le jeu est fini.
    * fonction de hashage : renvoie un couple (matrice applatie des cases, joueur courant).
    """
    NX,NY = None,None
    def __init__(self,grid=None,courant=None):
        self.grid = copy.deepcopy(grid) if grid is not None else np.zeros((self.NX,self.NY),dtype="int")
        self.courant = courant or 1
    def next(self,coup):
        pass
    def get_actions(self):
        pass
    def win(self):
        pass
    def stop(self):
        pass
    @classmethod
    def fromHash(cls,hash):
        return cls(np.array([int(i) for i in list(hash[0])],dtype="int").reshape((cls.NX,cls.NY)),hash[1])
    def hash(self):
        return ("".join(str(x+1) for x in self.grid.flat),self.courant)
            
class Jeu:
    """ Jeu generique, qui prend un etat initial et deux joueurs.
        run(self,draw,pause): permet de joueur une partie, avec ou sans affichage, avec une pause entre chaque coup. 
                Rend le joueur qui a gagne et log de la partie a la fin.
        replay(self,log): permet de rejouer un log
    """
    def __init__(self,init_state = None,j1=None,j2=None):
        self.joueurs = {1:j1,-1:j2}
        self.state = copy.deepcopy(init_state)
        self.log = None
    def run(self,draw=False,pause=0.5):
        log = []
        if draw:
            self.init_graph()
        while not self.state.stop():
            coup = self.joueurs[self.state.courant].get_action(self.state)
            log.append((self.state,coup))
            self.state = self.state.next(coup)
            if draw:
                self.draw(self.state.courant*-1,coup)
                plt.pause(pause)
        return self.state.win(),log
    def init_graph(self):
        self._dx,self._dy  = 1./self.state.NX,1./self.state.NY
        self.fig, self.ax = plt.subplots()
        for i in range(self.state.grid.shape[0]):
            for j in range(self.state.grid.shape[1]):
                self.ax.add_patch(patches.Rectangle((i*self._dx,j*self._dy),self._dx,self._dy,\
                        linewidth=1,fill=False,color="black"))
        plt.show(block=False)
    def draw(self,joueur,coup):
        color = "red" if joueur>0 else "blue"
        self.ax.add_patch(patches.Rectangle(((coup[0]+OFFSET)*self._dx,(coup[1]+OFFSET)*self._dy),\
                        self._dx*(1-2*OFFSET),self._dy*(1-2*OFFSET),linewidth=1,fill=True,color=color))
        plt.draw()
    def replay(self,log,pause=0.5):
        self.init_graph()
        for state,coup in log:
            self.draw(state.courant,coup)
            plt.pause(pause)

class MorpionState(State):
    """ Implementation d'un etat du jeu du Morpion. Grille de 3X3. 
    """
    NX,NY = 3,3
    def __init__(self,grid=None,courant=None):
        super(MorpionState,self).__init__(grid,courant)
    def next(self,coup):
        state =  MorpionState(self.grid,self.courant)
        state.grid[coup]=self.courant
        state.courant *=-1
        return state
    def get_actions(self):
        return list(zip(*np.where(self.grid==0)))
    def win(self):
        for i in [-1,1]:
            if ((i*self.grid.sum(0))).max()==3 or ((i*self.grid.sum(1))).max()==3 or ((i*self.grid)).trace().max()==3 or ((i*np.fliplr(self.grid))).trace().max()==3: return i
        return 0
    def stop(self):
        return self.win()!=0 or (self.grid==0).sum()==0
    def __repr__(self):
        return str(self.hash())

class Agent:
    """ Classe d'agent generique. Necessite une methode get_action qui renvoie l'action correspondant a l'etat du jeu state"""
    def __init__(self):
        pass
    def get_action(self,state):
        pass

class AgentAleatoire(Agent):
    def __init__(self):
        pass
    def get_action(self,state):
        return  random.choice(state.get_actions())

class AgentMonteCarlo(Agent):
    def __init__(self):
        pass
    def get_action(self,state):
        etat = copy.deepcopy(state)
        #on recupere le joueur courant pour savoir si cet etat est favorable ou pas
        who = etat.hash()[1]
        j1 = AgentAleatoire()
        j2 = AgentAleatoire()
        #on initialise les récompenses des actions à 0
        gain = [0 for i in range(len(state.get_actions()))]
        if len(state.get_actions()) == 1:
            return state.get_actions()[0]
        else:
            for i in range(100):
                #on recupere un coup aleatoirement parmis les coups possibles
                coup = random.choice(etat.get_actions())
                index = etat.get_actions().index(coup)
                #on passe a l'etat suivant
                etat = etat.next(coup)
                jeu = Jeu(etat, j1, j2) #on initialise le jeu
                res = jeu.run(False, sys.float_info.min) #on lance le jeu
                if (res[0] == who):  # le joueur a gagne
                    gain[index] += 1
                #reinitialisations pour les iterations suivantes
                etat = copy.deepcopy(state)
                who = etat.hash()[1]
            #on retourne l’action avec la meilleure probabilité de victoire
            return state.get_actions()[gain.index(max(gain))]
#implementation d'une structure d'arbre // un arbre est represente par son noeud racine
class Node:
    def __init__(self,coup,etat,gain,nbr,route,fils):
        self.coup = coup #le coup qui a permi de generer l'etat de ce noued a partir de l'etat de son pere
        self.etat = etat #l'etat qui correspond a ce noued
        self.gain = gain #le gain cumule de ce noeud
        self.nbr = nbr #le nombre de fois ou ce noeud a ete simule
        self.route = route #la route complete pour arriver de la racine de l'arbre jusqu'au noeud
        self.fils = fils #tableau qui contient les pointeurs vers les fils de ce noeud
    def propager_victoire(self,arbre):#methode pour propager une victoire dana l'arbre
        if (len(self.route) % 2) == 0:
            arbre.gain += 1
            arbre.nbr += 1
            cpt = 1
        else:
            arbre.nbr += 1
            cpt = 0
        node = arbre
        for i in range(len(self.route)):
            node = node.fils[self.route[i]]
            if cpt % 2 == 0 :
                node.nbr += 1
                node.gain += 1
            else:
                node.nbr += 1
            cpt+=1


    def propager_defaite(self,arbre):#methode pour propager une defaite dana l'arbre
        if (len(self.route) % 2) == 0:
            arbre.nbr += 1
            cpt = 0
        else:
            arbre.gain += 1
            arbre.nbr += 1
            cpt = 1
        node = arbre
        for i in range(len(self.route)):
            node = node.fils[self.route[i]]
            if cpt % 2 == 0:
                node.nbr += 1
                node.gain += 1
            else:
                node.nbr += 1
            cpt+=1
    def toString(self):
        print("-------new node-------")
        print("etat :",self.etat.get_actions())
        print("coup :",self.coup)
        print("gain :",self.gain)
        print("nombre :",self.nbr)
        print("route :",self.route)
        print("liste des fils :")
        for i in range(len(self.fils)):
            print("fils number :", i)
            self.fils[i].toString()
    
class AgentUCT:
    
    def __init__(self):
        pass
    def get_action(self,state):
        taille = len(state.get_actions())
        joueur1 = AgentAleatoire()
        joueur2 = AgentAleatoire()
        etat = copy.deepcopy(state)
        etatNode = copy.deepcopy(state)
        #initialisation de l'arbre avec comme racine l'etat courant du jeu
        arbre = Node((-1,-1),etatNode,0,0,[],[]) 

        #*******************initialisation des neouds enfants de la racine*******************
        for i in range(len(state.get_actions())):
            #on recupere le coup a jouer
            coup = etat.get_actions()[i]
            #on recupere le joueur courant pour savoir si cet etat est favorable ou pas
            courant = etat.hash()[1] 
            #on joue le coup et on recupere le nouvel etat
            etat = etat.next(coup) 
            #on fait une copie de l'etat pour le stocker dans un noeuds fils
            etatNode = copy.deepcopy(etat) 
            g = Jeu(etat,joueur1,joueur2) #on initialise le jeu
            res = g.run(False,sys.float_info.min) #on lance le jeu
            #creation d'un nouveau noeuds fils de la racine
            arbre.fils.append(Node(coup,etatNode,0,0,[i],[]))
            #si on gange on propage la victoire 
            if res[0] == courant : 
                arbre.fils[i].propager_victoire(arbre)
            #si on perd ou on fait un match nul on propage un defaite (on peut choisir de ranger le match nul en gain)
            else: 
                arbre.fils[i].propager_defaite(arbre)
            #on recupere l'etat initial pour creer les autres etats fils de la racine
            etat = copy.deepcopy(state) 

        #*******************on lance l'arbre de recherche pour un certain nombre d'iterations*******************
        i=0
        for i in range(10 * taille):
            #etape 1 : selction
            node = arbre #le node initial est la racine
            #tant que on a pas trouve une feuille ou un noeud auquel on peut ajouter des fils
            while (len(node.fils) != 0) and (len((node.etat).get_actions()) == len(node.fils)):
                gains =[]
                nbres = []
                #on lance ucb afin de recuperer le prochain noeud
                for i in range(len(node.fils)):
                    gains.append(node.fils[i].gain / node.fils[i].nbr)
                    nbres.append(node.fils[i].nbr)
                index = bm.ucb(gains,nbres)
                #on recupere le prochain noeud
                node = node.fils[index]
            #etape 2 : simulation + retropropagation, on a recupere le noeud : node
            # et donc si il n'est pas final on va explorer un nouvel etat
            if (node.etat.stop() == False):#si c'est pas un etat final
                # on fait une copie de etat courant
                etat = copy.deepcopy(node.etat)
                #on recupere un coup a joueur aleatoirement
                coup = random.choice(etat.get_actions())
                #on recupere le joueur courant pour savoir si cet etat est favorable ou pas
                courant = etat.hash()[1] 
                #on joue le coup
                etat = etat.next(coup)
                #on cree une copie de l'etat pour creer un noued fils
                etatNode = copy.deepcopy(etat)
                g = Jeu(etat,joueur1,joueur2) #on initialise le jeu
                res = g.run(False,sys.float_info.min) #on lance le jeu
                #on cree le noeud corespondant
                route = copy.deepcopy(node.route) #on recupere la route du noeud pere
                route.append(len(node.fils))#on complete la route au nouveau noeud
                fils = Node(coup,etatNode,0,0,route,[])
                node.fils.append(fils)#on rajoute le noeud dans les fils de son pere    
                #si on gange on propage la victoire(ce coup est favorable)          
                if res[0] == courant : 
                    fils.propager_victoire(arbre)
                #si on perd ou on fait un match nul on propage un defaite (on peut choisir de ranger le match nul en gain)
                else:
                    fils.propager_defaite(arbre)

        #on renvoie la meilleure action possible
        resultat = []
        for i in range (len(arbre.fils)):
            resultat.append(arbre.fils[i].gain / arbre.fils[i].nbr)
        resultat = np.array(resultat)
        return arbre.fils[np.argmax(resultat)].coup

